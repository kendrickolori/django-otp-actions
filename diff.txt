diff --git a/django_otp_actions/__pycache__/decorators.cpython-312.pyc b/django_otp_actions/__pycache__/decorators.cpython-312.pyc
index d944684..ecd8d26 100644
Binary files a/django_otp_actions/__pycache__/decorators.cpython-312.pyc and b/django_otp_actions/__pycache__/decorators.cpython-312.pyc differ
diff --git a/django_otp_actions/__pycache__/services.cpython-312.pyc b/django_otp_actions/__pycache__/services.cpython-312.pyc
index 268702c..2892644 100644
Binary files a/django_otp_actions/__pycache__/services.cpython-312.pyc and b/django_otp_actions/__pycache__/services.cpython-312.pyc differ
diff --git a/django_otp_actions/decorators.py b/django_otp_actions/decorators.py
index 019ca74..bf99862 100644
--- a/django_otp_actions/decorators.py
+++ b/django_otp_actions/decorators.py
@@ -1,14 +1,24 @@
-from .services import generate_otp, decrypt_context
+from functools import wraps
+from .services import generate_otp, validate_otp
+from .exceptions import (
+    InvalidOTPException,
+    OTPExpiredException,
+    SessionExpiredException,
+    MaxRetriesExceededException,
+    OTPException,
+)
 from rest_framework.response import Response
 from rest_framework import status
 
 
 def otp_protected():
+    """Decorator that injects generate_otp into request."""
+
     def decorator(func):
+        @wraps(func)  # ✅ Apply as decorator to wrapper
         def wrapper(request, *args, **kwargs):
             request.generate_otp = generate_otp
-            result = func(request, *args, **kwargs)
-            return result
+            return func(request, *args, **kwargs)
 
         return wrapper
 
@@ -16,9 +26,11 @@ def otp_protected():
 
 
 def verify_otp():
+    """Decorator that validates OTP before executing view."""
+
     def decorator(func):
+        @wraps(func)  # ✅ Apply as decorator to wrapper
         def wrapper(request, *args, **kwargs):
-            # Get OTP and context from request
             otp = str(request.data.get("otp", ""))
             encrypted_context = request.data.get("context", "")
 
@@ -29,31 +41,50 @@ def verify_otp():
                 )
 
             try:
-                # Decrypt context
-                context = decrypt_context(encrypted_context)
+                context = validate_otp(otp, encrypted_context)
+                request.otp_verified = True
+                request.otp_context = context
+                return func(request, *args, **kwargs)
 
-                # Verify OTP matches
-                if otp != str(context["code"]):
-                    return Response(
-                        {"error": "Invalid OTP"}, status=status.HTTP_400_BAD_REQUEST
-                    )
+            except InvalidOTPException as e:
+                return Response(
+                    {"error": str(e), "context": e.updated_context},
+                    status=status.HTTP_400_BAD_REQUEST,
+                )
 
-                # TODO: Check expiration (timestamp)
-                # TODO: Check identifier matches
+            except OTPExpiredException as e:
+                return Response(
+                    {"error": str(e), "error_code": "OTP_EXPIRED"},
+                    status=status.HTTP_410_GONE,
+                )
 
-                # OTP is valid - inject data into request
-                request.otp_verified = True
-                request.otp_context = context
+            except SessionExpiredException as e:
+                return Response(
+                    {"error": str(e), "error_code": "SESSION_EXPIRED"},
+                    status=status.HTTP_410_GONE,
+                )
 
-                # Call the actual view
-                return func(request, *args, **kwargs)
+            except MaxRetriesExceededException as e:
+                return Response(
+                    {"error": str(e), "error_code": "MAX_RETRIES_EXCEEDED"},
+                    status=status.HTTP_429_TOO_MANY_REQUESTS,
+                )
 
-            except Exception as e:
+            except OTPException as e:
                 return Response(
-                    {"error": "Invalid or expired OTP context"},
+                    {"error": str(e), "error_code": "OTP_ERROR"},
                     status=status.HTTP_400_BAD_REQUEST,
                 )
 
+            except Exception as e:
+                return Response(
+                    {
+                        "error": "An unexpected error occurred",
+                        "error_code": "INTERNAL_ERROR",
+                    },
+                    status=status.HTTP_500_INTERNAL_SERVER_ERROR,
+                )
+
         return wrapper
 
     return decorator
diff --git a/django_otp_actions/services.py b/django_otp_actions/services.py
index d75d956..7534a18 100644
--- a/django_otp_actions/services.py
+++ b/django_otp_actions/services.py
@@ -4,40 +4,17 @@ from datetime import datetime, timedelta
 from django.conf import settings
 import json
 from cryptography.fernet import Fernet
-
-
-# Custom Exceptions
-class OTPException(Exception):
-    """Base exception for OTP-related errors"""
-
-    pass
-
-
-class OTPExpiredException(OTPException):
-    """Raised when OTP has expired"""
-
-    pass
-
-
-class InvalidOTPException(OTPException):
-    """Raised when OTP doesn't match"""
-
-    pass
-
-
-class SessionExpiredException(OTPException):
-    """Raised when session has expired"""
-
-    pass
-
-
-class MaxRetriesExceededException(OTPException):
-    """Raised when maximum retry attempts exceeded"""
-
-    pass
+from .exceptions import (
+    OTPException,
+    OTPExpiredException,
+    MaxRetriesExceededException,
+    SessionExpiredException,
+    InvalidOTPException,
+)
 
 
 def encrypt_context(context):
+    """Encrypt context dictionary to string."""
     key = settings.OTP_SIGNING_KEY
     if isinstance(key, str):
         key = key.encode("utf-8")
@@ -51,6 +28,7 @@ def encrypt_context(context):
 
 
 def decrypt_context(encrypted_context):
+    """Decrypt context string to dictionary."""
     key = settings.OTP_SIGNING_KEY
     if isinstance(key, str):
         key = key.encode("utf-8")
@@ -67,16 +45,18 @@ def generate_otp(identifier=None, metadata=None, max_retries=3):
     """
     Generate OTP and encrypted context.
 
+    Note: Each call creates a NEW session window (15 minutes).
+    Requesting a new code resets the session timer.
+
     Args:
         identifier: Unique identifier (email, phone, etc.)
         metadata: Additional metadata to store
-        max_retries: Maximum number of retry attempts allowed
+        max_retries: Maximum number of retry attempts allowed (default: 3)
 
     Returns:
-        tuple: (otp, encrypted_context)
+        tuple: (otp_code, encrypted_context)
     """
     otp = random.randint(100000, 999999)
-
     now = datetime.now()
 
     context = {
@@ -94,7 +74,7 @@ def generate_otp(identifier=None, metadata=None, max_retries=3):
     return (str(otp), encrypted_context)
 
 
-def otp_valid(otp, encrypted_context):
+def validate_otp(otp, encrypted_context):
     """
     Validate OTP against encrypted context.
 
@@ -103,19 +83,20 @@ def otp_valid(otp, encrypted_context):
         encrypted_context: The encrypted context string
 
     Returns:
-        tuple: (is_valid, updated_encrypted_context)
+        dict: The decrypted context if valid
 
     Raises:
         SessionExpiredException: If session has expired
         OTPExpiredException: If OTP has expired
         MaxRetriesExceededException: If max retry attempts exceeded
-        InvalidOTPException: If OTP doesn't match
+        InvalidOTPException: If OTP doesn't match (includes updated context)
+        OTPException: For any other errors
     """
     try:
         context = decrypt_context(encrypted_context)
         current_time = datetime.now().timestamp()
 
-        # Check session expiry first
+        # Check session expiry first (most critical)
         if current_time > context.get("session_expiry", 0):
             raise SessionExpiredException(
                 "Session has expired. Please request a new OTP."
@@ -123,50 +104,61 @@ def otp_valid(otp, encrypted_context):
 
         # Check OTP expiry
         if current_time > context.get("otp_expiry", 0):
-            raise OTPExpiredException("OTP has expired. Please request a new OTP.")
-
-        # Increment retry count
-        context["retry_count"] = context.get("retry_count", 0) + 1
+            raise OTPExpiredException("OTP has expired. Please request a new OTP code.")
 
-        # Check if max retries exceeded (check after incrementing)
-        if context["retry_count"] > context.get("max_retries", 3):
+        # Check retry count BEFORE incrementing
+        if context["retry_count"] >= context.get("max_retries", 3):
             raise MaxRetriesExceededException(
-                f"Maximum retry attempts ({context.get('max_retries', 3)}) exceeded. Please request a new OTP."
+                f"Maximum retry attempts ({context.get('max_retries', 3)}) exceeded. "
+                "Please request a new OTP code."
             )
 
-        # Update encrypted context with new retry count
-        updated_encrypted_context = encrypt_context(context)
-
         # Check if OTP matches
         if context.get("code") != str(otp):
+            # Increment retry count
+            context["retry_count"] += 1
+            updated_context = encrypt_context(context)
+
+            attempts_remaining = context.get("max_retries", 3) - context["retry_count"]
+
             raise InvalidOTPException(
-                f"Invalid OTP. Attempts remaining: {context.get('max_retries', 3) - context['retry_count']}"
+                message=f"Invalid OTP. Attempts remaining: {attempts_remaining}",
+                updated_context=updated_context,
             )
 
-        # OTP is valid
-        return (True, updated_encrypted_context)
+        # OTP is valid - return the context
+        return context
 
-    except OTPException:
-        # Re-raise OTP-related exceptions
+    except (
+        OTPExpiredException,
+        MaxRetriesExceededException,
+        SessionExpiredException,
+        InvalidOTPException,
+    ):
+        # Re-raise OTP-specific exceptions as-is
         raise
     except Exception as e:
-        # Handle decryption or other errors
+        # Wrap any other errors (decryption, JSON parsing, etc.)
         raise OTPException(f"Error validating OTP: {str(e)}")
 
 
-def invalidate_otp(encrypted_context):
+def verify_otp(otp, encrypted_context):
     """
-    Invalidate an OTP by setting its expiry to the past.
+    Verify OTP and return context if valid.
+
+    This is a convenience wrapper around validate_otp that returns
+    the context on success. All exceptions are propagated upward.
 
     Args:
+        otp: The OTP code to verify
         encrypted_context: The encrypted context string
 
     Returns:
-        str: Updated encrypted context with expired OTP
+        dict: The decrypted context with metadata if valid
+
+    Raises:
+        All exceptions from validate_otp are propagated upward
     """
-    try:
-        context = decrypt_context(encrypted_context)
-        context["otp_expiry"] = 0  # Set to past timestamp
-        return encrypt_context(context)
-    except Exception as e:
-        raise OTPException(f"Error invalidating OTP: {str(e)}")
+    # Let all exceptions bubble up - decorator will handle them
+    context = validate_otp(otp, encrypted_context)
+    return context
diff --git a/django_otp_actions/tests.py b/django_otp_actions/tests.py
deleted file mode 100644
index 7ce503c..0000000
--- a/django_otp_actions/tests.py
+++ /dev/null
@@ -1,3 +0,0 @@
-from django.test import TestCase
-
-# Create your tests here.
